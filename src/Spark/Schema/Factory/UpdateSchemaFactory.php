<?php

declare(strict_types=1);

namespace JLucki\ODM\Spark\Schema\Factory;

use Exception;
use JLucki\ODM\Spark\Exception\NothingToUpdateException;
use JLucki\ODM\Spark\Exception\TableUpdateFailedException;
use JLucki\ODM\Spark\Schema\Helper\ArrayHelper;
use JLucki\ODM\Spark\Schema\Resolver\GlobalSecondaryIndexResolver;
use function count;

/**
 * The UpdateSchemaFactory renders an update schema array for the table formatted as per DynamoDB
 * requirements as outlined in the PHP SDK:
 *
 * https://docs.aws.amazon.com/aws-sdk-php/v2/api/class-Aws.DynamoDb.DynamoDbClient.html#_updateTable
 *
 * This schema is generated by comparing the original schema as provided by describeTable to the
 * current schema on the ItemInterface.
 *
 * Class SchemaFactory
 * @package JLucki\ODM\Spark\Schema
 */
class UpdateSchemaFactory
{

    /** @var array<string, mixed> */
    private const SUPPORTED_PROVISIONED_THROUGHPUT_PARAMETERS = [
        'ReadCapacityUnits' => '',
        'WriteCapacityUnits' => '',
    ];

    /** @var array<string, mixed> */
    private const SUPPORTED_PARAMETERS = [
        'TableName' => '',
        'KeySchema' => '',
        'AttributeDefinitions' => '',
        'ProvisionedThroughput' => self::SUPPORTED_PROVISIONED_THROUGHPUT_PARAMETERS,
        'GlobalSecondaryIndexes' => [
            [
                'IndexName' => '',
                'KeySchema' => '',
                'Projection' => '',
                'ProvisionedThroughput' => self::SUPPORTED_PROVISIONED_THROUGHPUT_PARAMETERS,
            ],
        ],
    ];

    /** @var array<string, mixed> */
    private array $updateSchema;

    /** @var array<string, mixed> */
    private array $newGlobalSecondaryIndexes;

    /** @var array<string, mixed> */
    private array $deletedGlobalSecondaryIndexes;

    /** @var array<string, mixed> */
    private array $updatedGlobalSecondaryIndexes;

    /**
     * UpdateSchemaFactory constructor.
     * @param array $describedSchema
     * @param array $localSchema
     * @throws NothingToUpdateException
     * @throws TableUpdateFailedException
     */
    public function __construct(
        /** @var array<string, mixed> */
        private array $describedSchema,
        /** @var array<string, mixed> */
        private array $localSchema,
    ) {
        $this->tidyDescribedSchema();
        $this->renderUpdateSchema();
    }

    /**
     * @return array<string, mixed>
     */
    public function getUpdateSchema(): array
    {
        return $this->updateSchema;
    }

    /**
     * @throws NothingToUpdateException
     * @throws TableUpdateFailedException
     */
    private function renderUpdateSchema(): void
    {
        $this->setSchemaSkeleton();
        $this->resolveGlobalSecondaryIndexes();
        $this->generateSchemaVariation();
    }

    private function resolveGlobalSecondaryIndexes(): void
    {
        $resolver = (new GlobalSecondaryIndexResolver())
            ->setLocalSchema($this->localSchema)
            ->setDescribedSchema($this->describedSchema)
            ->resolve();

        $this->newGlobalSecondaryIndexes = $resolver->getNewGlobalSecondaryIndexes();
        $this->deletedGlobalSecondaryIndexes = $resolver->getDeletedGlobalSecondaryIndexes();
        $this->updatedGlobalSecondaryIndexes = $resolver->getUpdatedGlobalSecondaryIndexes();
    }

    private function setSchemaSkeleton()
    {
        $schemaSkeleton = [
            'TableName' => $this->localSchema['TableName'],
        ];

        $this->updateSchema = $schemaSkeleton;
    }

    /**
     * @throws NothingToUpdateException
     * @throws TableUpdateFailedException
     */
    private function generateSchemaVariation(): void
    {
        $this->setTableName();
        $this->setKeySchema();
        $this->setAttributeDefinitions();
        $this->setProvisionThroughput();
        $this->setGlobalSecondaryIndexes();
        $this->validateSchemaVariation();
    }

    /**
     * @throws TableUpdateFailedException
     */
    private function setTableName(): void
    {
        if ($this->localSchema['TableName'] !== $this->describedSchema['TableName']) {
            throw new TableUpdateFailedException('updateTable doesn\'t support changing the table name');
        }
    }

    /**
     * @throws TableUpdateFailedException
     */
    private function setKeySchema(): void
    {
        $diff = ArrayHelper::getArrayDiff($this->localSchema['KeySchema'], $this->describedSchema['KeySchema']);
        if (count($diff) > 0) {
            throw new TableUpdateFailedException('updateTable doesn\'t support changing the table key schema');
        }
    }

    private function setAttributeDefinitions(): void
    {
        $diff = ArrayHelper::getArrayDiff($this->localSchema['AttributeDefinitions'], $this->describedSchema['AttributeDefinitions']);
        if (count($diff) > 0) {
            $this->updateSchema['AttributeDefinitions'] = $this->localSchema['AttributeDefinitions'];
        }
    }

    private function setProvisionThroughput(): void
    {
        $provisionedThroughput = [];

        $currentReadCapacityUnits = $this->localSchema['ProvisionedThroughput']['ReadCapacityUnits'];
        $describedReadCapacityUnits = $this->describedSchema['ProvisionedThroughput']['ReadCapacityUnits'];

        if ($currentReadCapacityUnits !== $describedReadCapacityUnits) {
            $provisionedThroughput['ReadCapacityUnits'] = $currentReadCapacityUnits;
        }

        $currentWriteCapacityUnits = $this->localSchema['ProvisionedThroughput']['WriteCapacityUnits'];
        $describedWriteCapacityUnits = $this->describedSchema['ProvisionedThroughput']['WriteCapacityUnits'];

        if ($currentWriteCapacityUnits !== $describedWriteCapacityUnits) {
            $provisionedThroughput['WriteCapacityUnits'] = $currentWriteCapacityUnits;
        }

        if (count($provisionedThroughput) > 0) {
            $this->updateSchema['ProvisionedThroughput'] = $provisionedThroughput;
        }
    }

    private function setGlobalSecondaryIndexes(): void
    {
        foreach ($this->newGlobalSecondaryIndexes as $newSecondaryIndex) {
            $this->updateSchema['GlobalSecondaryIndexUpdates'][] = [
                'Create' => $newSecondaryIndex,
            ];
        }

        foreach ($this->deletedGlobalSecondaryIndexes as $deletedSecondaryIndex) {
            $this->updateSchema['GlobalSecondaryIndexUpdates'][] = [
                'Delete' => [
                    'IndexName' => $deletedSecondaryIndex['IndexName'],
                ],
            ];
        }
        
        foreach ($this->updatedGlobalSecondaryIndexes as $updatedIndex) {
            $this->updateSchema['GlobalSecondaryIndexUpdates'][] = [
                'Update' => $updatedIndex,
            ];
        }
    }

    /**
     * Before determining the array differences, we'll remove
     * any unsupported values from the described schema
     */
    private function tidyDescribedSchema(): void
    {
        $this->describedSchema = $this->removeUnsupportedParameters($this->describedSchema, self::SUPPORTED_PARAMETERS);
    }

    /**
     * @param array $supportedParameters
     * @param mixed $parameter
     * @return bool
     */
    public function isRecursiveParameter(array $supportedParameters, mixed $parameter): bool
    {
        if (isset($supportedParameters[$parameter]) === true) {
            $supportedParameter = $supportedParameters[$parameter];
            if (is_array($supportedParameter) === true) {
                return count($supportedParameter) !== count($supportedParameter, COUNT_RECURSIVE);
            }
        }
        return false;
    }

    /**
     * @param array $parameters
     * @param array $supportedParameters
     * @param bool $isRecursiveParameter
     * @return array
     */
    public function removeUnsupportedParameters(array $parameters, array $supportedParameters, bool $isRecursiveParameter = false): array
    {
        if ($isRecursiveParameter === true) {
            foreach ($parameters as $parameter => $content) {
                $parameters[$parameter] = $this->removeUnsupportedParameters($content, $supportedParameters[0]);
            }
        } else {
            foreach ($parameters as $parameter => $content) {
                if (is_array($parameter) === false && in_array($parameter, array_keys($supportedParameters)) === false) {
                    unset($parameters[$parameter]);
                } elseif (is_array($content) === true && is_array($supportedParameters[$parameter]) === true) {
                    $isRecursiveParameter = $this->isRecursiveParameter($supportedParameters, $parameter);
                    $parameters[$parameter] = $this->removeUnsupportedParameters($content, $supportedParameters[$parameter], $isRecursiveParameter);
                }
            }
        }
        return $parameters;
    }

    /**
     * @throws NothingToUpdateException
     */
    private function validateSchemaVariation(): void
    {
        if (count($this->updateSchema) === 1) {
            throw new NothingToUpdateException();
        }
    }
}
