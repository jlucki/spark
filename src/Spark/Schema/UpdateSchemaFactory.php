<?php

declare(strict_types=1);

namespace JLucki\ODM\Spark\Schema;

use Exception;
use JLucki\ODM\Spark\Exception\TableUpdateFailedException;
use function count;

/**
 * The UpdateSchemaFactory renders an update schema array for the table formatted as per DynamoDB
 * requirements as outlined in the PHP SDK:
 *
 * https://docs.aws.amazon.com/aws-sdk-php/v2/api/class-Aws.DynamoDb.DynamoDbClient.html#_updateTable
 *
 * This schema is generated by comparing the original schema as provided by describeTable to the
 * current schema on the ItemInterface.
 *
 * Class SchemaFactory
 * @package JLucki\ODM\Spark\Schema
 */
class UpdateSchemaFactory
{

    /** @var array<string, mixed> */
    private const SUPPORTED_PROVISIONED_THROUGHPUT_PARAMETERS = [
        'ReadCapacityUnits' => '',
        'WriteCapacityUnits' => '',
        'OnDemand' => '',
    ];

    /** @var array<string, mixed> */
    private const SUPPORTED_PARAMETERS = [
        'TableName' => '',
        'KeySchema' => '',
        'AttributeDefinitions' => '',
        'ProvisionedThroughput' => self::SUPPORTED_PROVISIONED_THROUGHPUT_PARAMETERS,
        'GlobalSecondaryIndexes' => [
            [
                'IndexName' => '',
                'KeySchema' => '',
                'Projection' => '',
                'ProvisionedThroughput' => self::SUPPORTED_PROVISIONED_THROUGHPUT_PARAMETERS,
            ],
        ],
    ];

    /** @var array<string, mixed> */
    private array $updateSchema;

    /** @var array<string, mixed> */
    private array $newGlobalSecondaryIndexes;

    /** @var array<string, mixed> */
    private array $deletedGlobalSecondaryIndexes;

    /** @var array<string, mixed> */
    private array $updatedGlobalSecondaryIndexes;

    public function __construct(
        /** @var array<string, mixed> */
        private array $describedSchema,
        /** @var array<string, mixed> */
        private array $objectSchema,
    ) {
        $this->tidyDescribedSchema();
        $this->renderUpdateSchema();
    }

    /**
     * @return array<string, mixed>
     */
    public function getUpdateSchema(): array
    {
        return $this->updateSchema;
    }

    /**
     * @throws Exception
     */
    private function renderUpdateSchema(): void
    {
        $this->setSchemaSkeleton();

        $this->determineGlobalSecondaryIndexChanges();

        $this->generateSchemaVariation();
    }

    private function determineGlobalSecondaryIndexChanges(): void
    {
        $this->newGlobalSecondaryIndexes = $this->getIndexesDiff($this->objectSchema, $this->describedSchema);
        $this->deletedGlobalSecondaryIndexes = $this->getIndexesDiff($this->describedSchema, $this->objectSchema);
        $this->updatedGlobalSecondaryIndexes = $this->getUpdatedIndexes();
    }

    private function setSchemaSkeleton()
    {
        $schemaSkeleton = [
            'TableName' => $this->objectSchema['TableName'],
        ];

        $this->updateSchema = $schemaSkeleton;
    }

    /**
     * @throws Exception
     */
    private function generateSchemaVariation(): void
    {
        $this->setTableName();
        $this->setKeySchema();
        $this->setAttributeDefinitions();
        $this->setProvisionThroughput();
        $this->setGlobalSecondaryIndexes();
    }

    /**
     * @throws TableUpdateFailedException
     */
    private function setTableName(): void
    {
        if ($this->objectSchema['TableName'] !== $this->describedSchema['TableName']) {
            throw new TableUpdateFailedException('updateTable doesn\'t support changing the table name');
        }
    }

    /**
     * @throws TableUpdateFailedException
     */
    private function setKeySchema(): void
    {
        $diff = $this->getArrayDiff($this->objectSchema['KeySchema'], $this->describedSchema['KeySchema']);
        if (count($diff) > 0) {
            throw new TableUpdateFailedException('updateTable doesn\'t support changing the table key schema');
        }
    }

    private function setAttributeDefinitions(): void
    {
        $this->updateSchema['AttributeDefinitions'] = $this->objectSchema['AttributeDefinitions'];
    }

    /**
     * @throws TableUpdateFailedException
     */
    private function setProvisionThroughput(): void
    {
        $provisionedThroughput = [];

        $currentOnDemand = isset($this->objectSchema['ProvisionedThroughput']['OnDemand']) ? $this->objectSchema['ProvisionedThroughput']['OnDemand'] : false;
        $describedOnDemand = isset($this->describedSchema['ProvisionedThroughput']['OnDemand']) ? $this->describedSchema['ProvisionedThroughput']['OnDemand'] : false;

        if ($currentOnDemand !== $describedOnDemand) {
            throw new TableUpdateFailedException('updateTable does not support changing the capacity mode');
        }

        $currentReadCapacityUnits = $this->objectSchema['ProvisionedThroughput']['ReadCapacityUnits'];
        $describedReadCapacityUnits = $this->describedSchema['ProvisionedThroughput']['ReadCapacityUnits'];

        if ($currentReadCapacityUnits !== $describedReadCapacityUnits) {
            $provisionedThroughput['ReadCapacityUnits'] = $currentReadCapacityUnits;
        }

        $currentWriteCapacityUnits = $this->objectSchema['ProvisionedThroughput']['WriteCapacityUnits'];
        $describedWriteCapacityUnits = $this->describedSchema['ProvisionedThroughput']['WriteCapacityUnits'];

        if ($currentWriteCapacityUnits !== $describedWriteCapacityUnits) {
            $provisionedThroughput['WriteCapacityUnits'] = $currentWriteCapacityUnits;
        }

        if (count($provisionedThroughput) > 0) {
            $this->updateSchema['ProvisionedThroughput'] = $provisionedThroughput;
        }
    }

    private function setGlobalSecondaryIndexes(): void
    {
        foreach ($this->newGlobalSecondaryIndexes as $newSecondaryIndex) {
            $this->updateSchema['GlobalSecondaryIndexUpdates'][] = [
                'Create' => $newSecondaryIndex,
            ];
        }

        foreach ($this->deletedGlobalSecondaryIndexes as $deletedSecondaryIndex) {
            $this->updateSchema['GlobalSecondaryIndexUpdates'][] = [
                'Delete' => [
                    'IndexName' => $deletedSecondaryIndex['IndexName'],
                ],
            ];
        }
        
        foreach ($this->updatedGlobalSecondaryIndexes as $updatedIndex) {
            $this->updateSchema['GlobalSecondaryIndexUpdates'][] = [
                'Update' => $updatedIndex,
            ];
        }
    }

    /**
     * Before determining the array differences, we'll remove
     * any unsupported values from the described schema
     */
    private function tidyDescribedSchema(): void
    {
        $this->describedSchema = $this->removeUnsupportedParameters($this->describedSchema, self::SUPPORTED_PARAMETERS);
    }

    /**
     * @param array $parameters
     * @param array $supportedParameters
     * @param bool $isRecursiveParameter
     * @return array
     */
    private function removeUnsupportedParameters(array $parameters, array $supportedParameters, bool $isRecursiveParameter = false): array
    {
        if ($isRecursiveParameter === true) {
            foreach ($parameters as $parameter => $content) {
                $parameters[$parameter] = $this->removeUnsupportedParameters($content, $supportedParameters[0]);
            }
        } else {
            foreach ($parameters as $parameter => $content) {
                if (is_array($parameter) === false && in_array($parameter, array_keys($supportedParameters)) === false) {
                    unset($parameters[$parameter]);
                } elseif (is_array($content) === true && is_array($supportedParameters[$parameter]) === true) {
                    $isRecursiveParameter = $this->isRecursiveParameter($supportedParameters, $parameter);
                    $parameters[$parameter] = $this->removeUnsupportedParameters($content, $supportedParameters[$parameter], $isRecursiveParameter);
                }
            }
        }
        return $parameters;
    }

    /**
     * @param array $supportedParameters
     * @param mixed $parameter
     * @return bool
     */
    private function isRecursiveParameter(array $supportedParameters, mixed $parameter): bool
    {
        if (isset($supportedParameters[$parameter]) === true) {
            $supportedParameter = $supportedParameters[$parameter];
            if (is_array($supportedParameter) === true) {
                return count($supportedParameter) !== count($supportedParameter, COUNT_RECURSIVE);
            }
        }
        return false;
    }

    /**
     * @param array $first
     * @param array $second
     * @return array
     */
    private function getArrayDiff(array $first, array $second): array
    {
        return array_udiff_assoc($first, $second, function($a, $b) {
            return intval($a !== $b);
        });
    }

    /**
     * Returns indexes that exist in $schemaOne, but not in $schemaTwo
     *
     * @param array $schemaOne
     * @param array $schemaTwo
     * @return array
     */
    private function getIndexesDiff(array $schemaOne, array $schemaTwo): array
    {
        $indexes = [];
        foreach ($schemaOne['GlobalSecondaryIndexes'] as $schemaOneGlobalSecondaryIndex) {
            $existsInOneOnly = true;
            foreach ($schemaTwo['GlobalSecondaryIndexes'] as $schemaTwoGlobalSecondaryIndex) {
                if ($schemaOneGlobalSecondaryIndex['IndexName'] === $schemaTwoGlobalSecondaryIndex['IndexName']) {
                    $existsInOneOnly = false;
                    break;
                }
            }
            if ($existsInOneOnly === true) {
                $indexes[] = $schemaOneGlobalSecondaryIndex;
            }
        }
        return $indexes;
    }

    /**
     * @return array
     */
    private function getUpdatedIndexes(): array
    {
        $updatedIndexes = [];

        $currentGlobalSecondaryIndexes = $this->objectSchema['GlobalSecondaryIndexes'];
        $describedGlobalSecondaryIndexes = $this->describedSchema['GlobalSecondaryIndexes'];

        foreach ($currentGlobalSecondaryIndexes as $currentGlobalSecondaryIndex) {
            // we're only interested in indexes that exist on both the described
            // and object schemas to determine if the index was modified
            $isNew = $this->arrayHasKeyValue($this->newGlobalSecondaryIndexes, 'IndexName', $currentGlobalSecondaryIndex['IndexName']);
            $isDeleted = $this->arrayHasKeyValue($this->deletedGlobalSecondaryIndexes, 'IndexName', $currentGlobalSecondaryIndex['IndexName']);
            if ($isNew === true || $isDeleted === true) {
                continue;
            }
            // TODO: don't include ProvisionedThroughput if it hasn't changed, or the AWS SDK will throw an error
            $describedVersion = $this->getSubArrayByKeyValue($describedGlobalSecondaryIndexes, 'IndexName', $currentGlobalSecondaryIndex['IndexName']);
            $diff = $this->getArrayDiff([$currentGlobalSecondaryIndex], [$describedVersion]);
            if (count($diff) > 0) {
                $updatedIndexes[] = $diff[0];
            }
        }

        return $updatedIndexes;
    }

    /**
     * @param array $array
     * @param string $key
     * @param mixed $value
     * @return bool
     */
    private function arrayHasKeyValue(array $array, string $key, mixed $value): bool
    {
        foreach ($array as $item) {
            if (isset($item[$key]) === true && $item[$key] === $value) {
                return true;
            }
        }
        return false;
    }

    /**
     * @param array $array
     * @param string $key
     * @param mixed $value
     * @return array|null
     */
    private function getSubArrayByKeyValue(array $array, string $key, mixed $value): ?array
    {
        foreach ($array as $item) {
            if (isset($item[$key]) === true && $item[$key] === $value) {
                return $item;
            }
        }
        return null;
    }

}
